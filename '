import { createSlice } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

export interface TextState {
  bibleSummaries: BibleSummary[] | null,
  bibleSummariesLoading: boolean,
  bibleSummariesError: boolean,
}

const initialState: TextState = {
  bibleSummaries: null,
  bibleSummariesLoading: false,
  bibleSummariesError: false
}

export const textSlice = createSlice({
  name: 'text',
  initialState,
  reducers: {
    setBibleSummaries: (state, action: PayloadAction<BibleSummary[]>) => {
      state.bibleSummaries = action.payload
    },
    setBibleSummariesLoading: (state, action: PayloadAction<boolean>) => {
      state.bibleSummariesLoading = action.payload
    },
    setBibleSummariesError: (state, action: PayloadAction<boolean>) => {
      state.bibleSummariesError = action.payload
    },
  },
})

const fetchAllBibles = async () => {
  store.dispatch(setBibleSummariesLoading(true))
  store.dispatch(setBibleSummariesError(false))
  console.log(import.meta.env.VITE_API_BIBLE_KEY);
  try {
    const response = await apiBible.v1.getBibles(
      {},
      {
        headers: {
          "api-key": import.meta.env.VITE_API_BIBLE_KEY,
        },
      },
    );
    const data = (await response.json()).data as BibleSummary[];
    console.log(data);
    bibleSummaries.value = data;
  } catch (e) {
    console.error("Error fetching Bible summaries", e);
    bibleSummariesError.value = true;
  }
  store.dispatch(setBibleSummariesLoading(true))
};

void fetchAllBibles();


// Action creators are generated for each case reducer function
export const { setBibleSummaries, setBibleSummariesError, setBibleSummariesLoading } = textSlice.actions

export const counterReducer = textSlice.reducer;

import { signal, effect } from "@lit-labs/preact-signals";
import { BookTitle, TextAppearance, Translation } from "./types/textTypes";
import { textManager } from "./utils/TextManager";
import { apiBible } from "./api";
import { BibleSummary, Chapter } from "./api/ApiBible";
import { store } from '.'

interface UntrackedValue<T> {
  value: T;
}

export const textLoadingRequestNumber: UntrackedValue<number> = { value: 0 };

